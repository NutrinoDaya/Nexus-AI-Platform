"""
NexusAI Platform - Database Models
SQLAlchemy ORM models for all entities in the system
"""

import enum
from datetime import datetime
from typing import Optional

from sqlalchemy import (
    Boolean,
    Column,
    DateTime,
    Enum,
    Float,
    ForeignKey,
    Index,
    Integer,
    JSON,
    String,
    Table,
    Text,
    UniqueConstraint,
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
import uuid

from backend.core.database import Base


# ================================
# Enums
# ================================

class UserRole(str, enum.Enum):
    """User roles for access control"""
    ADMIN = "admin"
    USER = "user"
    VIEWER = "viewer"
    API_CLIENT = "api_client"


class ModelStatus(str, enum.Enum):
    """Model lifecycle status"""
    PENDING = "pending"
    ACTIVE = "active"
    DEPRECATED = "deprecated"
    FAILED = "failed"


class InferenceStatus(str, enum.Enum):
    """Inference job status"""
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class CameraStatus(str, enum.Enum):
    """Camera connection status"""
    ONLINE = "online"
    OFFLINE = "offline"
    ERROR = "error"
    DISABLED = "disabled"


class TaskType(str, enum.Enum):
    """AI task types"""
    OBJECT_DETECTION = "object_detection"
    INSTANCE_SEGMENTATION = "instance_segmentation"
    IMAGE_CLASSIFICATION = "image_classification"
    POSE_ESTIMATION = "pose_estimation"
    OBJECT_TRACKING = "object_tracking"
    FACIAL_RECOGNITION = "facial_recognition"
    OCR = "ocr"
    CUSTOM = "custom"


class ModelFramework(str, enum.Enum):
    """Supported model frameworks"""
    PYTORCH = "pytorch"
    ONNX = "onnx"
    TENSORRT = "tensorrt"
    OPENVINO = "openvino"
    TENSORFLOW = "tensorflow"


# ================================
# Association Tables
# ================================

# ================================
# Model Access Control Table
# ================================

class ModelAccess(Base):
    """
    Per-user model access permissions.
    
    This table enables fine-grained access control, allowing administrators
    to grant specific users access to specific models.
    
    Example: User A can only use Models 1, 3, 5 for inference.
    """
    __tablename__ = 'model_access'
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    model_id = Column(UUID(as_uuid=True), ForeignKey('models.id', ondelete='CASCADE'), nullable=False)
    
    # Permissions
    can_use = Column(Boolean, default=True, nullable=False, comment="Can run inference with this model")
    can_view = Column(Boolean, default=True, nullable=False, comment="Can view model details")
    can_edit = Column(Boolean, default=False, nullable=False, comment="Can edit model metadata")
    can_delete = Column(Boolean, default=False, nullable=False, comment="Can delete model")
    
    # Metadata
    granted_by_id = Column(UUID(as_uuid=True), ForeignKey('users.id', ondelete='SET NULL'), nullable=True)
    granted_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    expires_at = Column(DateTime(timezone=True), nullable=True, comment="Optional access expiry")
    notes = Column(String(500), nullable=True, comment="Reason for granting access")
    
    # Relationships
    user = relationship("User", foreign_keys=[user_id], back_populates="model_accesses")
    model = relationship("Model", foreign_keys=[model_id], back_populates="user_accesses")
    granted_by = relationship("User", foreign_keys=[granted_by_id])
    
    __table_args__ = (
        UniqueConstraint('user_id', 'model_id', name='unique_user_model_access'),
        Index('idx_model_access_user', 'user_id'),
        Index('idx_model_access_model', 'model_id'),
    )
    
    def is_expired(self) -> bool:
        """Check if access has expired"""
        if self.expires_at is None:
            return False
        return datetime.utcnow() > self.expires_at
    
    def has_permission(self, permission: str) -> bool:
        """
        Check if user has specific permission for this model.
        
        Args:
            permission: Permission type ('use', 'view', 'edit', 'delete')
        
        Returns:
            bool: True if user has permission and access hasn't expired
        """
        if self.is_expired():
            return False
        
        permission_map = {
            'use': self.can_use,
            'view': self.can_view,
            'edit': self.can_edit,
            'delete': self.can_delete
        }
        
        return permission_map.get(permission, False)


# Deprecated: Old association table (kept for backward compatibility migration)
user_model_access = Table(
    'user_model_access_legacy',
    Base.metadata,
    Column('user_id', UUID(as_uuid=True), ForeignKey('users.id', ondelete='CASCADE')),
    Column('model_id', UUID(as_uuid=True), ForeignKey('models.id', ondelete='CASCADE')),
    Column('granted_at', DateTime(timezone=True), server_default=func.now()),
    UniqueConstraint('user_id', 'model_id', name='unique_user_model_access_legacy'),
)


camera_group_association = Table(
    'camera_group_association',
    Base.metadata,
    Column('camera_id', UUID(as_uuid=True), ForeignKey('cameras.id', ondelete='CASCADE')),
    Column('group_id', UUID(as_uuid=True), ForeignKey('camera_groups.id', ondelete='CASCADE')),
    UniqueConstraint('camera_id', 'group_id', name='unique_camera_group'),
)


# ================================
# User Model
# ================================

class User(Base):
    """User account with role-based access control"""
    __tablename__ = 'users'
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String(100), unique=True, nullable=False, index=True)
    email = Column(String(255), unique=True, nullable=False, index=True)
    hashed_password = Column(String(255), nullable=False)
    full_name = Column(String(255))
    role = Column(Enum(UserRole), default=UserRole.USER, nullable=False, index=True)
    
    is_active = Column(Boolean, default=True, nullable=False)
    is_verified = Column(Boolean, default=False, nullable=False)
    
    failed_login_attempts = Column(Integer, default=0, nullable=False)
    locked_until = Column(DateTime(timezone=True), nullable=True)
    
    api_key = Column(String(64), unique=True, nullable=True, index=True)
    api_key_created_at = Column(DateTime(timezone=True), nullable=True)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    last_login_at = Column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    model_accesses = relationship("ModelAccess", foreign_keys="[ModelAccess.user_id]", back_populates="user", cascade="all, delete-orphan")
    models = relationship("Model", secondary=user_model_access, back_populates="authorized_users")  # Legacy
    inference_jobs = relationship("InferenceJob", back_populates="user", cascade="all, delete-orphan")
    cameras = relationship("Camera", back_populates="owner", foreign_keys="Camera.owner_id")
    audit_logs = relationship("AuditLog", back_populates="user", cascade="all, delete-orphan")
    
    __table_args__ = (
        Index('idx_users_role_active', 'role', 'is_active'),
    )


# ================================
# Model Registry
# ================================

class Model(Base):
    """AI Model registry with versioning and access control"""
    __tablename__ = 'models'
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(255), nullable=False)
    slug = Column(String(255), unique=True, nullable=False, index=True)
    description = Column(Text)
    
    task_type = Column(Enum(TaskType), nullable=False, index=True)
    framework = Column(Enum(ModelFramework), nullable=False)
    version = Column(String(50), nullable=False)
    
    # Storage paths
    model_path = Column(String(500), nullable=False)
    config_path = Column(String(500), nullable=True)
    
    # Model metadata
    input_size = Column(JSON)  # [height, width] or custom
    output_classes = Column(Integer, nullable=True)
    class_names = Column(JSON, nullable=True)
    
    # Performance metrics
    expected_fps = Column(Float, nullable=True)
    max_latency_ms = Column(Float, nullable=True)
    
    # Configuration
    preprocessing_config = Column(JSON, nullable=True)
    inference_config = Column(JSON, nullable=True)
    device = Column(String(20), default="cuda")
    batch_size = Column(Integer, default=1)
    
    # Access control
    access_level = Column(String(20), default="authenticated")  # public, authenticated, premium, private
    
    # Status
    status = Column(Enum(ModelStatus), default=ModelStatus.PENDING, nullable=False, index=True)
    is_default = Column(Boolean, default=False)
    
    # MLflow integration
    mlflow_run_id = Column(String(100), nullable=True)
    mlflow_model_uri = Column(String(500), nullable=True)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    created_by = Column(UUID(as_uuid=True), ForeignKey('users.id'), nullable=True)
    
    # Relationships
    user_accesses = relationship("ModelAccess", foreign_keys="[ModelAccess.model_id]", back_populates="model", cascade="all, delete-orphan")
    authorized_users = relationship("User", secondary=user_model_access, back_populates="models")  # Legacy
    inference_jobs = relationship("InferenceJob", back_populates="model", cascade="all, delete-orphan")
    
    __table_args__ = (
        UniqueConstraint('name', 'version', name='unique_model_version'),
        Index('idx_models_task_status', 'task_type', 'status'),
    )


# ================================
# Inference Jobs
# ================================

class InferenceJob(Base):
    """Inference job tracking with results"""
    __tablename__ = 'inference_jobs'
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # User and model
    user_id = Column(UUID(as_uuid=True), ForeignKey('users.id', ondelete='SET NULL'), nullable=True, index=True)
    model_id = Column(UUID(as_uuid=True), ForeignKey('models.id', ondelete='CASCADE'), nullable=False, index=True)
    
    # Input/Output
    input_path = Column(String(500), nullable=False)
    output_path = Column(String(500), nullable=True)
    input_type = Column(String(20), nullable=False)  # image, video, stream
    
    # Status and timing
    status = Column(Enum(InferenceStatus), default=InferenceStatus.PENDING, nullable=False, index=True)
    started_at = Column(DateTime(timezone=True), nullable=True)
    completed_at = Column(DateTime(timezone=True), nullable=True)
    processing_time_ms = Column(Float, nullable=True)
    
    # Results
    result_data = Column(JSON, nullable=True)
    num_detections = Column(Integer, nullable=True)
    confidence_avg = Column(Float, nullable=True)
    
    # Metadata
    inference_params = Column(JSON, nullable=True)
    metadata = Column(JSON, nullable=True)
    error_message = Column(Text, nullable=True)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    # Relationships
    user = relationship("User", back_populates="inference_jobs")
    model = relationship("Model", back_populates="inference_jobs")
    
    __table_args__ = (
        Index('idx_inference_status_created', 'status', 'created_at'),
        Index('idx_inference_user_created', 'user_id', 'created_at'),
    )


# ================================
# Camera Management
# ================================

class CameraGroup(Base):
    """Camera organization groups"""
    __tablename__ = 'camera_groups'
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    # Relationships
    cameras = relationship("Camera", secondary=camera_group_association, back_populates="groups")


class Camera(Base):
    """Camera/Stream configuration and monitoring"""
    __tablename__ = 'cameras'
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    
    # Connection
    stream_url = Column(String(500), nullable=False)
    protocol = Column(String(20), nullable=False)  # rtsp, webrtc, http, usb
    username = Column(String(100), nullable=True)
    password = Column(String(255), nullable=True)
    
    # Status
    status = Column(Enum(CameraStatus), default=CameraStatus.OFFLINE, nullable=False, index=True)
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Configuration
    fps = Column(Integer, default=30)
    resolution = Column(JSON, default=[1920, 1080])
    buffer_size = Column(Integer, default=60)
    
    # Analytics
    enable_inference = Column(Boolean, default=False)
    inference_interval = Column(Integer, default=1)  # seconds
    model_id = Column(UUID(as_uuid=True), ForeignKey('models.id'), nullable=True)
    
    # Recording
    enable_recording = Column(Boolean, default=False)
    recording_path = Column(String(500), nullable=True)
    retention_days = Column(Integer, default=7)
    
    # Motion detection
    enable_motion_detection = Column(Boolean, default=False)
    motion_sensitivity = Column(Integer, default=50)
    
    # Health metrics
    last_frame_at = Column(DateTime(timezone=True), nullable=True)
    current_fps = Column(Float, nullable=True)
    dropped_frames = Column(Integer, default=0)
    latency_ms = Column(Float, nullable=True)
    
    # Metadata
    manufacturer = Column(String(100), nullable=True)
    model_name = Column(String(100), nullable=True)
    location = Column(String(255), nullable=True)
    metadata = Column(JSON, nullable=True)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    owner_id = Column(UUID(as_uuid=True), ForeignKey('users.id'), nullable=True)
    
    # Relationships
    owner = relationship("User", back_populates="cameras", foreign_keys=[owner_id])
    groups = relationship("CameraGroup", secondary=camera_group_association, back_populates="cameras")
    events = relationship("CameraEvent", back_populates="camera", cascade="all, delete-orphan")
    
    __table_args__ = (
        Index('idx_cameras_status_active', 'status', 'is_active'),
    )


# ================================
# Camera Events
# ================================

class CameraEvent(Base):
    """Events detected from camera streams"""
    __tablename__ = 'camera_events'
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    camera_id = Column(UUID(as_uuid=True), ForeignKey('cameras.id', ondelete='CASCADE'), nullable=False, index=True)
    
    event_type = Column(String(50), nullable=False, index=True)  # motion, object_detected, etc.
    severity = Column(String(20), default="info")  # info, warning, critical
    
    description = Column(Text, nullable=True)
    event_data = Column(JSON, nullable=True)
    
    thumbnail_path = Column(String(500), nullable=True)
    video_clip_path = Column(String(500), nullable=True)
    
    detected_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    acknowledged = Column(Boolean, default=False)
    acknowledged_at = Column(DateTime(timezone=True), nullable=True)
    acknowledged_by = Column(UUID(as_uuid=True), ForeignKey('users.id'), nullable=True)
    
    # Relationships
    camera = relationship("Camera", back_populates="events")
    
    __table_args__ = (
        Index('idx_events_camera_detected', 'camera_id', 'detected_at'),
        Index('idx_events_type_detected', 'event_type', 'detected_at'),
    )


# ================================
# System Settings
# ================================

class SystemSetting(Base):
    """Dynamic system configuration settings"""
    __tablename__ = 'system_settings'
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    key = Column(String(100), unique=True, nullable=False, index=True)
    value = Column(JSON, nullable=False)
    category = Column(String(50), nullable=False, index=True)
    description = Column(Text, nullable=True)
    
    is_public = Column(Boolean, default=False)  # Can non-admin users read this?
    
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    updated_by = Column(UUID(as_uuid=True), ForeignKey('users.id'), nullable=True)


# ================================
# Audit Logs
# ================================

class AuditLog(Base):
    """Audit trail for all significant actions"""
    __tablename__ = 'audit_logs'
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey('users.id', ondelete='SET NULL'), nullable=True, index=True)
    
    action = Column(String(100), nullable=False, index=True)
    resource_type = Column(String(50), nullable=False)
    resource_id = Column(String(100), nullable=True)
    
    details = Column(JSON, nullable=True)
    ip_address = Column(String(45), nullable=True)
    user_agent = Column(String(500), nullable=True)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    # Relationships
    user = relationship("User", back_populates="audit_logs")
    
    __table_args__ = (
        Index('idx_audit_user_created', 'user_id', 'created_at'),
        Index('idx_audit_action_created', 'action', 'created_at'),
    )


# Export all models
__all__ = [
    "User",
    "UserRole",
    "Model",
    "ModelStatus",
    "TaskType",
    "ModelFramework",
    "InferenceJob",
    "InferenceStatus",
    "Camera",
    "CameraGroup",
    "CameraStatus",
    "CameraEvent",
    "SystemSetting",
    "AuditLog",
]
